using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.Composition.Hosting;
using System.Linq;
using Microsoft.VisualStudio.Modeling;
using NuPattern.Library;
using NuPattern.Library.Automation;
using NuPattern.Runtime;
using NuPattern.Runtime.Composition;
using NuPattern.Runtime.Schema;
using JsonConvert = NuPattern.Runtime.Serialization.JsonConvert;

namespace CodeGenerationCommandDump
{
    class Program
    {
        static void Main(string[] args)
        {
            // The path of a DSL model file:
            var dslModel =
                args.Length > 0
                ? args[0]
                : @"D:\dev\particular\servicematrix\src\ServiceMatrix\PatternModel.patterndefinition";


            // The Model type generated by the DSL:
            IPatternModelSchema patternModel;

            // Set up the Store to read your type of model:

            Type[] domainTypes = { PatternModelReader.DomainModelType, Type.GetType("NuPattern.Library.Automation.LibraryDomainModel, NuPattern.Library") };

            var container = new CompositionContainer(new DirectoryCatalog(AppDomain.CurrentDomain.BaseDirectory));
            var compositionService =
                (INuPatternCompositionService)Activator.CreateInstance(
                    Type.GetType("NuPattern.Runtime.Bindings.ContainerCompositionServiceAdapter, NuPattern.Runtime.Extensibility"),
                    container);

            var store = new Store(
                new TrivialServiceProvider(
                    new Dictionary<Type, object>
                    {
                        { typeof(INuPatternCompositionService), compositionService},
                        { typeof(INuPatternProjectTypeProvider), new TrivialNuPatternProjectTypeProvider()}
                    }),
                domainTypes);
            var serializationResult = new SerializationResult();

            // All Store changes must be in a Transaction:
            using (Transaction t =
              store.TransactionManager.BeginTransaction("Load model"))
            {
                patternModel = PatternModelReader.Read(serializationResult, store, dslModel);
                t.Commit(); // Don't forget this!
            }

            DumpPatternModel(patternModel);
        }

        private static void DumpPatternModel(IPatternModelSchema patternModel)
        {
            var designView = patternModel.Pattern.Views.First();
            foreach (var element in ((IElementInfoContainer)designView).Elements)
            {
                DumpElement(element, 0);
            }
        }

        private static void DumpElement(IAbstractElementInfo element, int indentationLevel)
        {
            var indentation = new string(' ', indentationLevel * 2);
            Console.WriteLine(indentation + "Element: " + element.Name);

            var allCommands =
                element.AutomationSettings
                    .Where(s => s.AutomationType == "Command")
                    .Select(s => s.As<ICommandSettings>())
                    .ToList();
            var allCommandsById = allCommands.ToDictionary(c => c.Id, c => c);

            var interestingCommands = new HashSet<Guid>();

            // code generation commands
            var codeGenerationCommands =
                allCommands
                    .Where(cs =>
                        cs.TypeId.Contains("GenerateComponentCodeCommand")
                        || cs.TypeId.Contains("GenerateProductCodeCommandCustom")
                        || cs.TypeId.Contains("GenerateProductCodeCommand"))
                    .ToList();

            foreach (var commandSetting in codeGenerationCommands)
            {
                Console.WriteLine("{0}  Code: {1} ({2})", indentation, commandSetting.Name, commandSetting.TypeId);
                foreach (var property in commandSetting.Properties)
                {
                    Console.WriteLine("{0}    {1} = {2}", indentation, property.Name, property.Value);
                }

                interestingCommands.Add(commandSetting.Id);
            }

            // aggregates
            var aggregatorCommands = allCommands.Where(cs => cs.TypeId.Contains("AggregatorCommand")).ToList();
            bool aggregatorAdded;
            do
            {
                aggregatorAdded = false;
                foreach (var aggregatorCommand in aggregatorCommands)
                {
                    var references =
                        JsonConvert.DeserializeObject<Collection<CommandReference>>(aggregatorCommand.Properties.First(p => p.Name == "CommandReferenceList").Value);

                    if (references.Any(r => interestingCommands.Contains(r.CommandId)))
                    {
                        aggregatorAdded = interestingCommands.Add(aggregatorCommand.Id);
                    }
                }
            } while (aggregatorAdded);

            foreach (var aggregatorCommand in aggregatorCommands.Where(ac => interestingCommands.Contains(ac.Id)))
            {
                Console.WriteLine("{0}  Aggregate: {1}", indentation, aggregatorCommand.Name);

                var i = 0;
                foreach (var reference in
                    JsonConvert.DeserializeObject<Collection<CommandReference>>(aggregatorCommand.Properties.First(p => p.Name == "CommandReferenceList").Value))
                {
                    var command = allCommandsById[reference.CommandId];
                    Console.WriteLine(
                        "{0}    {3}: {1}{2}",
                        indentation,
                        command.Name,
                        interestingCommands.Contains(reference.CommandId) ? " (*)" : "",
                        i++);
                }
            }

            // launch points

            foreach (var setting in element.AutomationSettings.Where(s => s.AutomationType != "Command"))
            {
                var automation = setting.As<IAutomationSettings>();

                var me = (ModelElement)automation;
                var prop = me.GetDomainClass().FindDomainProperty("CommandId", true);
                if (prop != null)
                {
                    var commandId = (Guid)prop.GetValue(me);
                    if (interestingCommands.Contains(commandId))
                    {
                        Console.WriteLine(
                            "{0}  Launch: {1} ({2}) -> {3}",
                            indentation,
                            automation.Name,
                            setting.AutomationType,
                            allCommandsById[commandId].Name);
                    }
                }
            }

            foreach (var childElement in element.Elements)
            {
                DumpElement(childElement, indentationLevel + 1);
            }
        }
    }

    public class TrivialServiceProvider : IServiceProvider
    {
        private readonly IDictionary<Type, object> services;

        public TrivialServiceProvider(IDictionary<Type, object> services)
        {
            this.services = services;
        }

        public object GetService(Type serviceType)
        {
            object service;

            return services.TryGetValue(serviceType, out service) ? service : null;
        }
    }

    public class TrivialNuPatternProjectTypeProvider : INuPatternProjectTypeProvider
    {
        private IList<Type> allTypes;

        public IEnumerable<Type> GetTypes<T>()
        {
            if (allTypes == null)
            {
                allTypes = AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToList();
            }

            return allTypes;
        }
    }


}