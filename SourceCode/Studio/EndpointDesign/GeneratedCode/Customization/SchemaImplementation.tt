<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\DslDefinition.dsl'" #>
<#@ Include File="..\..\DslVersion.tt" #>
<#@ Include File="..\..\Helpers.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Linq.Expressions;
using NServiceBus.Modeling.EndpointDesign.Interfaces;

<#
foreach (var domainClass in this.DslLibrary.Classes)
{
	GenerateClass(domainClass);
}

foreach (var relation in this.DslLibrary.Relationships.Where(r => r.Properties.Count > 0))
{
	if (!HasSkipAnnotation(relation.Notes))
		GenerateRelationClass(relation);
}

#>
<#+
private void GenerateClass(DomainClass domainClass)
{
#>
namespace <#= domainClass.Namespace #>
{<#+
PushIndent("\t"); 

var baseInterface = CodeGenerationUtilities.GetBaseClass(domainClass, string.Empty);
#>

/// <summary>
/// <#= domainClass.Description #>
/// </summary>
[GeneratedCode("<#= domainClass.Namespace #>", "<#= this.DslVersion #>")]
public partial class <#= domainClass.Name #> : I<#= domainClass.Name #>
{ <#+
	foreach (var role in domainClass.RolesPlayed)
	{
		GenerateProperty(domainClass, role);

		if (!role.IsMany && role.Relationship.Properties.Count > 0 && !HasSkipAnnotation(role.Relationship.Notes))
		{
			GenerateLinkProperty(domainClass, role.Relationship);
		}
	}
	if (string.IsNullOrEmpty(baseInterface))
	{
#>

	/// <summary>
	/// Gets a value indicating whether this instance is serializing.
	/// </summary>
	/// <value>
	/// <c>true</c> if this instance is serializing; otherwise, <c>false</c>.
	/// </value>
	protected bool IsSerializing()
	{
		return this.Store.TransactionManager.InTransaction &&
			this.Store.TransactionManager.CurrentTransaction.IsSerializing;
	}
<#+
	}
#>
}
<#+	PopIndent(); #>
}
<#+
}

private void GenerateRelationClass(DomainClass domainClass)
{
#>
namespace <#= domainClass.Namespace #>
{
<#+
PushIndent("\t"); 

#>

/// <summary>
/// <#= domainClass.Description #>
/// </summary>
[GeneratedCode("<#= domainClass.Namespace #>", "<#= this.DslVersion #>")]
public partial class <#= domainClass.Name #> : I<#= domainClass.Name #>
{
}
<#+	PopIndent(); #>
}
<#+
}

private void GenerateProperty(DomainProperty property)
{
	PushIndent("\t");
#>

/// <summary>
/// <#= property.Description #>
/// </summary>
<#= CodeGenerationUtilities.GetDomainTypeFullName(property) #> <#= property.Name #> { get; set; }
<#+
	PopIndent();
}

private void GenerateLinkProperty(DomainClass domainClass, DomainRelationship relationship)
{
	PushIndent("\t");
#>

/// <summary>
/// <#= relationship.Description #>
/// </summary>
I<#= relationship #> I<#= domainClass.Name #>.<#= relationship.Name #>
{
	get { return DomainRoleInfo.GetElementLinks<<#= relationship.Name #>>(this, <#= relationship.Name #>.<#= relationship.Target.Name #>DomainRoleId).FirstOrDefault(); }
}
<#+
	PopIndent();
}

private void GenerateProperty(DomainClass domainClass, DomainRole role)
{
	if (!role.IsPropertyGenerator) 
	{
		return;
	}

	var opposite = role.Opposite;
	var castString = string.Empty;
	var propertyType = opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	var typeRole = role;
	for (var current = role.BaseRole; current != null; current = current.BaseRole)
	{
		if (current!= role && current.IsPropertyGenerator && current.PropertyName==role.PropertyName)
		{
			if ((current.Relationship.InheritanceModifier==InheritanceModifier.Abstract || role.Relationship.InheritanceModifier==InheritanceModifier.Abstract) &&
			    current.Relationship.InheritanceModifier != role.Relationship.InheritanceModifier)
			{
				break;
			}
			else 
			{
				typeRole = current;
			}
		}
	}

	if (typeRole != role)
	{
		castString = "(" + propertyType + ")";
		propertyType = typeRole.Opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	}

	// Determine collection type for the property.
	string linkedElementCollectionType;
	if (typeRole.CollectionType!=null)
	{
		// If a custom collection type was specified, use it.
		linkedElementCollectionType = StripGenericSpecification(CodeGenerationUtilities.GetDomainTypeFullName(typeRole.CollectionType, role.RolePlayer.Namespace));
	}
	else
	{
		switch (typeRole.Relationship.InheritanceModifier)
		{
			case InheritanceModifier.Abstract:
				linkedElementCollectionType = "DslModeling::ReadOnlyLinkedElementCollection";
				break;
			case InheritanceModifier.None:
			case InheritanceModifier.Sealed:
				linkedElementCollectionType = "DslModeling::LinkedElementCollection";
				break;
			default:
				throw new NotSupportedException();
		}
	}

	PushIndent("\t");

	if (!HasSkipAnnotation(role.Notes))
	{
		if (role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne)
		{
#>

/// <summary>
/// <#= role.Description #>
/// </summary>
I<#= propertyType #> I<#= domainClass.Name #>.<#= role.PropertyName #>
{
	get { return this.<#= role.PropertyName #>; }
	set { this.<#= role.PropertyName #> = (<#= propertyType #>)value; }
}
<#+
		}
		else
		{
			var schemaField = Char.ToLower(domainClass.Name[0]) + domainClass.Name.Substring(1) + role.PropertyName;
			var infoField = Char.ToLower(domainClass.Name[0]) + domainClass.Name.Substring(1) + role.PropertyName;
#>

/// <summary>
/// <#= role.Description #>
/// </summary>
IEnumerable<I<#= propertyType #>> I<#= domainClass.Name #>.<#= role.PropertyName #>
{
	get { return this.<#= role.PropertyName #>.Cast<I<#= propertyType #>>(); }
}
<#+
		}
	}

	// Generate Create factory methods.
	if (opposite.IsEmbedded)
	{
		if (opposite.RolePlayer.InheritanceModifier != InheritanceModifier.Abstract)
		{
			ImplementCreate(propertyType, role.Opposite.PropertyName);
			ImplementDelete(propertyType, role.Opposite.PropertyName);
		}

		foreach (var derived in opposite.RolePlayer.AllDescendants.Where(dc => dc.InheritanceModifier != InheritanceModifier.Abstract))
		{
			var derivedType = derived.GetRelativeName(derived.Namespace, true);
			ImplementCreate(derivedType, role.Opposite.PropertyName);
			ImplementDelete(derivedType, role.Opposite.PropertyName);
		}
	}

	PopIndent();
}

private void ImplementCreate(string propertyType, string propertyName)
{
#>

/// <summary>
/// Creates an instance of a child <see cref="I<#= propertyType #>"/>.
/// </summary>
public I<#= propertyType #> Create<#= propertyType #>()
{
	return this.Create<#= propertyType #>(null);
}

/// <summary>
/// Creates an instance of a child <see cref="I<#= propertyType #>"/> with an optional initializer to perform 
/// object initialization within the creation transaction.
/// </summary>
public I<#= propertyType #> Create<#= propertyType #>(Action<I<#= propertyType #>> initializer)
{
	using (var tx = this.Store.TransactionManager.BeginTransaction("Creating new instance of <#= propertyType #>", this.IsSerializing()))
	{
		var instance = this.Create<<#= propertyType #>>();
		if (initializer != null)
		{
			initializer(instance);
		}

		tx.Commit();
		return instance;
	}
}
<#+
}

private void ImplementDelete(string propertyType, string propertyName)
{
#>

/// <summary>
/// Deletes an instance of a child <see cref="I<#= propertyType #>"/>.
/// </summary>
public void Delete<#= propertyType #>(I<#= propertyType #> instance)
{
	using (var tx = this.Store.TransactionManager.BeginTransaction("Deleting <#= propertyType #> instance", this.IsSerializing()))
	{
		var modelElement = instance as <#= propertyType #>;
		if (modelElement != null)
		{
			modelElement.Delete();
		}

		tx.Commit();
	}
}
<#+
}
#>
