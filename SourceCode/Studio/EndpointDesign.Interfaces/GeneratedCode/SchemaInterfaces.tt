<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\EndpointDesign\DslDefinition.dsl'" #>
<#@ Include File="..\..\EndpointDesign\DslVersion.tt" #>
<#@ Include File="..\..\EndpointDesign\Helpers.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq.Expressions;

<#
foreach (var domainClass in this.DslLibrary.Classes)
{
	GenerateInterface(domainClass);
}
#>
<#+
private void GenerateInterface(DomainClass domainClass)
{
#>
namespace NServiceBus.Modeling.EndpointDesign.Interfaces
{ <#+
PushIndent("\t"); 

string baseInterface = "";
baseInterface = CodeGenerationUtilities.GetBaseClass(domainClass, baseInterface);
#>

/// <summary>
/// <#= domainClass.Description #>
/// </summary>
[Description("<#= domainClass.Description #>")]
[GeneratedCode("<#= this.ToolName #>", "<#= this.DslVersion #>")]
public partial interface I<#= domainClass.Name #> <#+ if (!string.IsNullOrEmpty(baseInterface)) { #>: I<#= baseInterface #><#+ } #> 
{<#+
	if (string.IsNullOrEmpty(baseInterface))
	{
#>

	/// <summary>
	/// Gets the identifier for this element.
	/// </summary>
	[Description("Gets the identifier for this element.")]
	global::System.Guid Id { get; } <#+
	}

	foreach (var property in domainClass.Properties)
	{
		if (!HasSkipAnnotation(property.Notes))
		{
			GenerateProperty(property);
		}
	}
	
	foreach(DomainRole role in domainClass.RolesPlayed)
	{
		GenerateProperty(role);
	}

	if (string.IsNullOrEmpty(baseInterface))
	{
#>
<#+ 
	}
#>
}
<#+	PopIndent(); #>
}

<#+
}
private void GenerateProperty(DomainProperty property)
{
	if (!PropertyHasGetter(property) && !PropertyHasSetter(property))
		return;

	PushIndent("\t");
#>

/// <summary>
/// <#= property.Description #>
/// </summary>
[Description("<#= property.Description #>")]
<#+
	if (property.IsUIReadOnly)
	{
		// UI readonly does not mean that we don't have API access, 
		// but rather that the setter is just not available via UI.
 #>
[System.ComponentModel.ReadOnly(true)]
<#+
	} 
#>
<#= CodeGenerationUtilities.GetDomainTypeFullName(property) #> <#= property.Name #> { <#+ if(PropertyHasGetter(property)){ #>get;<#+ } if(PropertyHasSetter(property)) { #> set;<#+ } #> }
<#+
	PopIndent();
}

private bool PropertyHasSetter(DomainProperty property)
{
	if (property.Kind == PropertyKind.Calculated)
		return false;
	if (property.SetterAccessModifier != AccessModifier.Public)
		return false;

	return true;
}

private bool PropertyHasGetter(DomainProperty property)
{
	if (property.GetterAccessModifier != AccessModifier.Public)
		return false;

	return true;
}

private void GenerateProperty(DomainRole role)
{
	if (!role.IsPropertyGenerator) 
	{
		return;
	}

	DomainRole opposite = role.Opposite;
	string castString = "";
	string propertyType = opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	DomainRole typeRole = role;
	
	for (DomainRole current = role.BaseRole; current!=null; current = current.BaseRole)
	{
		if(current!= role && current.IsPropertyGenerator && current.PropertyName==role.PropertyName)
		{
			if((current.Relationship.InheritanceModifier==InheritanceModifier.Abstract || role.Relationship.InheritanceModifier==InheritanceModifier.Abstract) && current.Relationship.InheritanceModifier != role.Relationship.InheritanceModifier)
			{
				break;
			}
			else 
			{
				typeRole = current;
			}
		}
	}

	if(typeRole!=role)
	{
		castString = "("+propertyType+")";
		propertyType = typeRole.Opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	}

	// Determine collection type for the property.
	string linkedElementCollectionType;
	
	if (typeRole.CollectionType != null)
	{
		// If a custom collection type was specified, use it.
		linkedElementCollectionType = StripGenericSpecification(CodeGenerationUtilities.GetDomainTypeFullName(typeRole.CollectionType, role.RolePlayer.Namespace));
	}
	else
	{
		switch (typeRole.Relationship.InheritanceModifier)
		{
			case InheritanceModifier.Abstract:
				linkedElementCollectionType = "DslModeling::ReadOnlyLinkedElementCollection";
				break;
			case InheritanceModifier.None:
			case InheritanceModifier.Sealed:
				linkedElementCollectionType = "DslModeling::LinkedElementCollection";
				break;
			default:
				throw new NotSupportedException();
		}
	}

	PushIndent("\t");

	if (!HasSkipAnnotation(role.Notes))
	{
#>

/// <summary>
/// <#= role.Description #>
/// </summary>
[Description("<#= role.Description #>")]
<#+
		if(role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne)
		{
#>
I<#= propertyType #> <#= role.PropertyName #> { get; set; }
<#+
		}
		else
		{
#>
IEnumerable<I<#= propertyType #>> <#= role.PropertyName #> { get; }
<#+
		}
	}

	GenerateCreate(opposite, propertyType);
	GenerateDelete(opposite, propertyType);

	PopIndent();
}

private void GenerateCreate(DomainRole opposite, string propertyType)
{
	// Generate Create factory methods.
	if (opposite.IsEmbedded)
	{
		if (opposite.RolePlayer.InheritanceModifier != InheritanceModifier.Abstract)
		{
#>

/// <summary>
/// Creates an instance of a child <see cref="I<#= propertyType #>"/>, which is automatically added to the <c><#= opposite.Opposite.PropertyName #></c> collection.
/// </summary>
I<#= propertyType #> Create<#= propertyType #>(Action<I<#= propertyType #>> initializer = null);
<#+
		}

		foreach (var derived in opposite.RolePlayer.AllDescendants.Where(dc => dc.InheritanceModifier != InheritanceModifier.Abstract))
		{
			var derivedType = derived.GetRelativeName(derived.Namespace, true);
#>

/// <summary>
/// Creates an instance of a child <see cref="I<#= derivedType #>"/>, which is automatically added to the <c><#= opposite.Opposite.PropertyName #></c> collection.
/// </summary>
I<#= derivedType #> Create<#= derivedType #>(Action<I<#= derivedType #>> initializer = null);
<#+
		}
	}
}
private void GenerateDelete(DomainRole opposite, string propertyType)
{
	// Generate Create factory methods.
	if (opposite.IsEmbedded)
	{
		if (opposite.RolePlayer.InheritanceModifier != InheritanceModifier.Abstract)
		{
#>

/// <summary>
/// Deletes an instance of a child <see cref="I<#= propertyType #>"/>, which is removed from the <c><#= opposite.Opposite.PropertyName #></c> collection.
/// </summary>
void Delete<#= propertyType #>(I<#= propertyType #> instance);
<#+
		}
	}
}

#>